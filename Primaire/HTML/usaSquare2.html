<!DOCTYPE html>
<meta charset="utf-8">
<head>
		<script src="../JS/Tabletop.js" charset="utf-8"></script>
		<script src="http://d3js.org/queue.v1.min.js"></script>
		<script src="http://d3js.org/d3.v3.min.js"></script>
		<script src="../JS/tip.js" charset="utf-8"></script>
		<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="../CSS/general.css" />
	
</head>		
<body>
<div class="box">
<p align="center">
  <svg></svg>
</div>
<!-- When import this way, the data is available as global variable "gridmapLayoutUsa" -->
<script src="../JS/etats.js"></script>
<script>
var width = 700,
    height = 600,
    padding = 0, // separation between nodes
    maxRadius = 12 ;

var public_spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1lMb_c6dGcmpsluqg1DR1Cic5b5b9gs344rlqDOuD6ZA/pubhtml'	
	
	
// Define color scale
var color = function(x) {
	if (x<30)
		return '#006d2c';
	else if (x<40)
		return '#2ca25f';
	else if (x<45)
		return '#66c2a4';
	else if (x<55)
		return '#999999';
	else if (x<60)
		return '#74a9cf';
	else if (x<70)
		return '#2b8cbe';
	else
		return '#045a8d';		
}
var xRange = d3.scale.linear()
  .domain([0, 30])
  .range([40,800-40]);  
var yRange = d3.scale.linear()
  .domain([1, 30])
  .range([40,800-40]); 
var radRange = d3.scale.linear()
  .domain([0, 550])
  .range([10,32]); 

var svg = d3.select('svg')
	.attr("viewBox", [
       0,
       0,
       width,
       height
     ].join(" ")); 
	 
var dataLoc = gridmapLayoutUsa;

var recherche = function(name) {
var index=-1;
	for (i = 0; i < dataLoc.length; i++) { 
		if (dataLoc[i].name==name) 
			index=i;
}
return index;
}

var tip = d3.tip()
		.attr('class', 'd3-tip')
		.offset([-10, 0])
		.html(function(d) {
			return "<p class='titre'>&nbsp;"+d.nameFR+"</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nombre de délégués Clinton : "+d.clinton+"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nombre de délégués Sanders : "+d.sanders+"<br>&nbsp;";
		});


function drawChart(data) {
var nodes = d3.range(data.length).map(function(i) {
  var name = data[i].État_EN;
  var nameFR = data[i].État_FR;
  var key = dataLoc[recherche(name)].key
  var xt = dataLoc[recherche(name)].x;
  var yt = dataLoc[recherche(name)].y;
  var rad = data[i].Nombre_de_délégués_par_État;
  var clin = parseInt(data[i].Délégués_Clinton);
  var san = parseInt(data[i].Délégués_Sanders);
  var col = 100*(clin/(clin + san));
	return {
	key : key,
	name: name,
	nameFR : nameFR,
	radius: radRange(rad),
	clinton : clin,
	sanders : san,
    x: xRange(xt),
    y: yRange(yt),
	x0: xRange(xt),
    y0: yRange(yt),
	color : color(col)
  };
});
	
var force = d3.layout.force()
	.gravity(0.2)
	.charge(0)
	.nodes(nodes)
	.size([width, height]);
	
var group = svg.selectAll("g")
  .data(nodes)
  .enter()
  .append('g')
  .attr('transform', function(d){return 'translate('+d.x0+','+d.y0+')';});
  
 
var rectangle =  group.append("rect")
  .attr("class","rectangle")
  .attr("width", function(d) { return d.radius*2; })
  .attr("height", function(d) { return d.radius*2; })
  .style("fill", function(d) { return d.color; })
  .style("opacity", "1")
  .attr("stroke-width", "0.5px")
  .attr("stroke", "white")
  .on('mouseover', tip.show)
  .on('mouseout', tip.hide)
  .call(force.drag);
  
var text = group.append('text')
  .attr("class","nomEtat")
  .attr("dx", ".1em")
  .attr("dy", "1em")
  .text(function(d) {return d.key;})
  .style("fill","#e5e5e5")
  .on('mouseover', tip.show)
  .on('mouseout', tip.hide);
  
  function gravity(alpha) {
  return function(d) {
    d.y += (d.y0 - d.y) * alpha;
    d.x += (d.x0 - d.x) * alpha;
  };
}

force.on('tick', function(e) {
	var q = d3.geom.quadtree(nodes),
		i = 0,
		n = nodes.length;
	while (++i < n) {
		q.visit(collide(nodes[i]));
	}
	svg.selectAll('rect')
		.attr('x', function(d) { return d.x; })
		.attr('y', function(d) { return d.y; });
});

force.start();

function collide(node) {
	return function(quad, x1, y1, x2, y2) {
		var updated = false;
		if (quad.point && (quad.point !== node)) {
			var x = node.x - quad.point.x,
				y = node.y - quad.point.y,
				xSpacing = (quad.point.radius + node.radius) / 2,
				ySpacing = (quad.point.radius + node.radius) / 2,
				absX = Math.abs(x),
				absY = Math.abs(y),
				l,
				lx,
				ly;
			if (absX < xSpacing && absY < ySpacing) {
				l = Math.sqrt(x * x + y * y);
				lx = (absX - xSpacing) / l;
				ly = (absY - ySpacing) / l;
				// the one that's barely within the bounds probably triggered the collision
				if (Math.abs(lx) > Math.abs(ly)) {
					lx = 0;
				} else {
					ly = 0;
				}
				node.x -= x *= lx;
				node.y -= y *= ly;
				quad.point.x += x;
				quad.point.y += y;
				updated = true;
			}
		}
		return updated;
	};
}

};
  
 function renderSpreadsheetData() {
    Tabletop.init( { key: public_spreadsheet_url,
                     callback: draw,
                     simpleSheet: true } )
}

	function draw(data, tabletop) {
  // draw chart
  drawChart(data);
	}
  
renderSpreadsheetData();
svg.call(tip);	

</script>